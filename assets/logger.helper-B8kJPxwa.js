const o=class o{};o.getValueOrDefault=(a,s)=>a===void 0?s:a,o.getPropertyValue=(a,s,r)=>o.getValueOrDefault(a.hasOwnProperty(s)?a[s]:void 0,r);let i=o;const t=class t{};t._groups={all:!1},t.isGroupActive=({group:a,type:s})=>{const r=i.getPropertyValue(t._groups,"all",!1),e=i.getPropertyValue(r,s),c=i.getPropertyValue(t._groups,a,!1),u=i.getPropertyValue(c,s);return e!==void 0?e:r!==void 0&&typeof r=="boolean"?r:u!==void 0?u:c},t.treatLogger=a=>s=>(r,...e)=>{if(t.isGroupActive({group:s,type:a}))try{console[a].apply(r,[new Date().toUTCString(),r,...e])}catch(c){if(!t.isGroupActive({group:s,type:"error"}))return;console.error("LoggerHelper > treatLogger",c)}},t.init=a=>{t._groups={...t._groups,...a}},t.error=t.treatLogger("error"),t.log=t.treatLogger("log"),t.warn=t.treatLogger("warn");let l=t;export{i as C,l as L};
